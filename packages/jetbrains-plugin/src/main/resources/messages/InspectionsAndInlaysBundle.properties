group.names.probable.bugs=Probable bugs
inspection.field.checking=Field does not exist in collection
inspection.field.checking.error.message=Field "{0}" does not exist in collection "{1}"
inspection.field.checking.error.message.value.type.mismatch=A "{0}"(type of provided value) can not be assigned to "{1}"(type of "{2}")
inspection.field.checking.error.message.no.connection=No connection available to run this check.
inspection.field.checking.error.message.no.database=No database selected to run this check.
inspection.field.checking.quickfix.choose.new.connection=Choose new connection

inspection.namespace.checking.error.message=Namespace could not be detected.
inspection.namespace.checking.error.message.database.missing=Cannot resolve "{0}" database reference in the connected data source.
inspection.namespace.checking.error.message.collection.missing=Cannot resolve "{0}" collection in "{1}" database in the connected data source.

inspection.index.checking.error.query.not.covered.by.index=\
  To optimize query performance in MongoDB, consider leveraging indexes on frequently queried fields. \
  Indexes store a subset of the collection's data, enabling efficient document retrieval and minimizing \
  the number of documents examined.\n\n\
  By carefully designing indexes based on your application's query patterns you can significantly \
  enhance query speed, reduce resource consumption and improve scalability. Especially for large \
  datasets and complex queries, indexes are crucial for maintaining optimal performance as your \
  data volume grows.

inspection.index.checking.error.query.not.covered.by.index.quick.fix=Implement an index

notification.group.inspection.results=MongoDB Inspection Results
inlay.namespace.name=MongoDB Namespace Inlay

